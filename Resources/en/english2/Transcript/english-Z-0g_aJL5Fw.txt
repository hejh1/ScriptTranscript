Design TikTok.  - Hey everyone, I'm here today with Adam and today we'll be doing a mock system design interview. I'm really excited to have Adam in this video. Adam, do you mind just introducing yourself and telling us a little bit about what you work on? - Sure, hi, my name's Adam. I work on cloud engineering and backend systems. Currently at Oracle, but I'll be moving over to Google soon.
Awesome. Yeah, we're really excited to jump into a practice system design interview today. The question that we'll be doing is design TikTok. Okay, cool, design TikTok. Well, this is a fun, I actually have never used TikTok. Great. So maybe we can start by just quickly kind of, if you could give me, or I have an idea, obviously I know what it is, but if you can just kind of give me a quick overview of what we're we're looking for, it may be a little bit
specific on the portion of TikTok we're wanting to focus on. Awesome. Yeah. So yeah, high level overview of TikTok is it's a mobile app. So it's for video sharing between users. And the basic idea is you're able to upload a video to TikTok. And then you're able to view a feed of videos. So you see one video time, you scroll up, you see the next video. You can follow users. So you see their videos at the end.
that they post. And then you can also perform actions on those videos like favoriting them or commenting on them, I think. So those are sort of the basic things we'll want to support. Cool. All right, that makes sense. So if it's all right, I'm just going to take a minute and kind of jot down some notes real quick. Sounds great. Yeah, I mean, time I'll switch over and just screen share here into our whiteboard. Cool. So it looks like TikTok is a mobile app.
If it's okay with you, I think I'm just going to focus on sort of the backend infrastructure and not so much go into the mobile app portion. Just because I think there's a little bit more feature rich detail there, the backend system. Yeah, sounds great. But what I can see, the first thing I kind of want to dive into are sort of these functional requirements. And what I say functional requirements, I just kind of mean, you know, the sort of top level buckets of work that we're wanting to do.
into it to look into. So the first thing from what you explained to me was upload videos, right? So a user from their mobile device or or really a theory since we're just dividing the device in the back end of it's okay. I'm going to assume that we're just going to create an API that is sort of client agnostic that's going to accept user data to upload videos. So we're going to kind of think sort of section one here if I was going to write this up. These
Functional. I'm just going to say number one here is upload videos. And so when we upload videos, these videos are, they're sort of time boxed, right? It's sort of in the same way of Instagram, like they only are about 15 seconds each. Is that right? Yeah, and yeah, I can, we can assume they're, you know, 30 seconds to maybe a maximum of like a minute long. Okay, so max.
one minute. Cool. And I'm also assuming that if I'm uploading videos, there's also, would there be like text associated with that, like sort of like with the Instagram or Facebook where you can upload a photo, but you can also like tag and add like text and you know things like that. Yeah, that's a good question. Yeah, let's assume like yeah, you can add like a comment or caption to it, we don't need to get maybe into the details.
of like tagging and how that would work, but yeah, maybe some text data associated with it. Okay, cool. I deleted what I was writing here. So let's say video plus text. Cool. And then kind of number two here, what I'm thinking is you said view feed. So when I think about, you know, doing the feed, what we're doing is we're aggregating and and correct me from all we're talking about aggregating videos from
Is it people I follow only? Is it people I follow plus sort of like, I know that TikTok has this special algorithm that they used to grab recommended videos? Would it be kind of like, can I assume there's sort of a mixture of those two things? - Yeah, I think that's a good question. First simplicity, we could focus maybe on videos of people you follow, but would be interested in hearing about sort of how you would sort of create like a trending or like video.
a recommendation as well. For the purposes of this, do you want me to include an ability for me to comment like videos as part of that functionality? Yeah, let's try to build out how we would favorite videos and maybe follow particular creators. Okay, cool. So yeah, that's actually my next functional requirement here, which just kind of follow users.
So, favoriting, following, commenting, forwarding, I don't know if they allowed that, but just, I'll just kind of bucket that as like a sort of video interaction endpoint. Sure. Cool. All right. So, that kind of covers these as like the general functional requirements. So, really quickly, I just want to talk about these non-functional. So really non-functional, what I mean by that is kind of like
Let's start with availability, availability, latency and scale. It sounds to me like I'm in a make an assumption that this is a hot needs to be a highly available system.
just simply because of the way, the scale of the users that are going to be using it, sounds like it's going to be a lot. And it really, because of this serving videos, it does need to be highly available. So I'm just going to say roughly highly available. I'm going to say around 99.999%. If that's correct, that sounds about right for you. Yeah, that sounds great. 'cause like, you know, there's always you.
these trade-offs, right? Like when we talk about, when I'm thinking about how I'm gonna design a system, I'm just trying to understand, like if it's not super high, like if it's maybe less, doesn't need to be as highly available, maybe there's certain things we can do to balance our budget and how we're gonna budget for our compute resources and that sort of thing. So cool. So I also think about latency. You know, the one good thing is we're from the SATA that since it is a mobile device, sounds like you can kind of cash a lot of it.
content on the device itself. So when we initially pull stuff, we'll be able to obviously get the top level stuff really quickly. But after that, we can kind of be pulling stuff in the background. So we do-- it sounds like we have a little bit of leeway there. Is that sound about right to you? Yeah, that sounds good. I think maybe later on, we can talk a little bit about the latency or how this would differ across different features, like upload versus download, and how to think about that. OK. I'll just put TVD for that.
Cool. And then scale. So can you just give me a rough estimate on like, if we're talking about users, can you have any kind of idea how many users we're talking about here like in a day? Yeah, in a day. Let's say we want to support like a million active users in a day. Okay.
So a million daily active users. Cool. So I'm just gonna do a couple of estimates here and now that we're talking about this. So just this gives me an idea of, how I'm gonna store everything. So we said max here for the video. Videos were about, what's the one minute? I'm just gonna make a quick assumption and say that a minute of compressed H264 video is about five megabytes.
to you. And then maybe we can say each user is uploading to per day equals 10 megabytes per day per day per user. I'm not going to get too much into this yet. I just want to get a rough idea for the big chunk here, which is videos. You know, the rest of it user metadata is going to be minimal. I think it's going to be, you know, 1k per user per day.
I think that's a pretty good estimate, roughly. Cool, okay, cool. So I think with all that, is there anything else I'm kind of, you can see that I'm missing here? Is that seem like a rough, good, I sort of overview of the system that we're trying to attack all here? - Yeah, it seems like a good overview. I think we can dive in now. - Okay, cool. So I think I'm gonna start with just kind of a couple of API endpoints just to get a wrap my head around. So I think what I'd like to start with is
We'll just start here and we'll say upload video, just because we have it. Really, that's going to be... If I talk about, I don't want you to much in the parameters of it, but if I talk about the database schema that sort of backs that, really, our user object is going to be something along the lines of... We're going to have some sort of user ID.
And that's going to be like a UID. We're going to have a some sort of video link. That's actually, I'll get to that later, but I think that's going to be, once we upload the video, we're going to want to store it. I think it's some sort of blob storage, like S3. So this will be a fully qualified link to that object. So let's do like in URL.
And then maybe meta, this would be just like meta data. This would just be string data. So that's kind of the first end point I'm thinking. So let me just kind of go into that real quick. I'm not gonna get into much of the user detail stuff here, just 'cause I think that sort of solves problem. I think we can get to that if we have time. But for the scope of this, I'm not really gonna talk too much about it.
So, I'm just going to take a minute and kind of think of this through. Okay, cool. So I think, obviously, we're going to want some sort of database, right, to back this. And this is going to be where we store this table. So I'm assuming this is going to be pretty much the same.
Right now I'm just going to make an assumption that this is going to be a relational database, Postgres, whatever flavor of relational database you so choose. So upload video is going to send this object to the relational database. Could you just briefly talk about maybe the differences between a relational database versus another type of database and why we might want to use this? Yeah, so like a really.
relational database versus like a no SQL database, for example, relation is going to be a little bit more structured in the data. So typically you'll use relational databases for things like user data objects, linking different tables together. So for example, you can have like a single user that has many videos. So you would have that many video objects. And those can be stored in two different tables. You can do SQL queries against those. Things like no SQL databases are really good for.
unstructured data, like log data, things like that. So a little bit more freeform in nature, not as structured in the sense that you're going to be querying that data and doing a lot of joins to it. You're kind of just going to be more like freeform searching for key values, keys and values inside that data. So yeah, in this case, you know, relational database can be relational database can can be a lot more strict, but can also be more...
more space and speed efficient for specific query. So yeah, I think that makes sense here. So yeah, like I think what we do is upload the video object to this database, or sorry, rather, this would actually just be the video data, right? It would, it would be the best way to describe this video. I just saved a video table, right? So this is going to send to the video table.
The idea here is that this is just the data because what we're then going to want to do is send the actual video object to some sort of cloud bucket, like I mentioned before. So like s3. This is cloud thing. So like this would be like a blob store. The idea here is that the video itself actually lives here and then in this table.
we have a link to that. So we're going to be running like a post, oops, really running a post to this API endpoint, this upload video endpoint. So I'm running out of space. Let me just move all this over a bit. This would be my video plus my user information.
upload video accepts the video and the user information. We save it in the table, we upload it to Blob Storage, and then we're going to return some sort of 200 response, which is what the API would respond with to the app itself, saying that the video is correct. That handles our upload section. It's pretty straightforward for the upload section there. Is there any questions about that? Or did you have anything I missed there? And no, I think that makes a lot of sense.
Yeah, we have the overview of where the video goes, where the metadata goes, and how the app would sort of make that request. So I think that makes sense. Cool. Awesome. So let's talk really quick about view feed. So this will be a similar endpoint view feed. And what this is actually going to be is a get request.
So when you open up the app, So when you open up the app, I think we want to load this content Right when the application opens, Like I'm guessing we want to start pre-loading as much as we can ahead of time so that the user isn't waiting too much for videos to load, right? Yeah, I think we'd want to do that. And so far as it would let us view videos faster.
but maybe not so much that it would, you know, maybe use a user bandwidth and things like that. Yeah, I think maybe like the top, like the, whatever the first like three videos, for example, we'd want to just grab those as quick as possible. Because the reason I asked that is I think it would make sense to sort of like have some sort of like reddest cache over here, some sort of cache, whatever it is, and the idea here would be
that we actually preload a list of like user, like the top 10 videos that we're going to load for the user before they even get to the view feed page. So like if a user with a specific user, UID hits this view feed, we're going to grow to this cache that's already prebuilt. And we're going to grab those top videos that are already pre-selected. So like for example, this UID.
would give me this would respond with like, you know, 10 videos, video links rather, that are associated with that user ID and the links for the blob storage so that the app would then be grabbing them from the blob storage right away. Does that make sense? Yeah, that makes sense. Yeah, that's super interesting. Can you tell me a little bit more about how the cash would work or? Yeah. So I'm actually thinking about a service here in the that would run.
So this would sort of like it be a pre-cash service, pre-cash service. And this would just kind of run potentially on like a schedule, but also just like maybe on demand, something like that. And what it would do is it would compile playlists for users and pre-cash them. So it could be potentially like, potentially like we could sort of base it on when the user
actually goes and does the get request that we sort of preload it for the next one, or we just do it in the background. There's a couple of strategies we could use there. What I'm trying to get away from is relying too much, because from what I can tell, this system seems very readable. There's going to be a lot of reading going on. In addition to having this main database, which I'll get to scaling, I think for this main main read data this.
main database, we're also going to want to have some sort of read worker, which would be like a read only database. And the reason being we don't want to create too much load on this single database that's accepting these uploads, we want to have something that's managing the reads. So in fact, I would actually do something like this where the second area is pulling from the primary, and this is used for read only, which builds the pre-cash,
loads of the cache, which then, when the U of B gets hit, it loads it instantly. Right. At least the query, right? So does that make sense? Yeah, that makes a lot of sense. I think getting back to one of the first questions about latency, can you talk a little bit about how introducing this cache would sort of affect latency in the system and seeing updates and things like that? Yeah, for sure. So one thing we need to consider is how quickly we want, like if, I don't know if
actually the video that I upload. I don't think that would show up in my feed. And if so, yeah, I think we'd, what, so this feed is basically a curated list of videos. So I think the point here is that, 'cause I know that TikTok has like a special algorithm they use to populate your feed. So I'm trying to get rid of all that happening at the moment of get, like at the moment of loading the app. I'm trying to have it prebuilt, right? so that right away we're getting what we made from the back end.
and now having to wait for some sort of service to compile that on the fly. Plus, this also solves a little bit of our scaling issue because if we have situations where you can imagine TikTok has a million users, if one million users all get on at the same time and run the same exact query, we could really kill our databases because we're running all these queries at the same time and we could also up that latency. So you can solve that with some like, like auto scaling.
groups, but even auto scaling groups take time to sort of spin up. So that's kind of the thing I'm thinking about here. But the real key here is I think I just noticed that this seems very read heavy, so I was trying to get to the point where those reads were sort of managed on their own. Yeah, I think that's a great insight. Cool. I think that kind of handles the view feed for the most part. Yeah, I feel pretty good about that. Last piece here would be favoriting video.
I think we would have just another endpoint here where we would. Sorry, I put another one in there. So I think we have another one. And this would just be like, I'm just going to call this. User activity, maybe, or something like that. This would be. That's a little bit generic, but I'm going to speed through this. We're in a little bit long time. I try and name it something better in the real world. something more descriptive of what it actually did.
But the idea here is that when I hit the user activity, this is like follow, this is doing liking videos, that sort of thing. And I apologize, I'm actually gonna just move this around a little bit so that I can get to my database cleaner. Yeah, no, it's not. Yeah, just put this down a bit. So yeah, the idea behind user activity this is literally just going to hit
this RDP, the database. And so for my, I would actually have a different table here. I'd have like a some sort of, I'll just put this over here, yeah, put it right here for now. So this table would look something along the lines. It's still have a user ID and a UUID. I think we would have, so, yeah, I think, I think this would be like a followers,
like a user activity table and the idea here would be, we're gonna need a couple of keys here. So following is actually gonna have to be a foreign key to another table. Because we're gonna have, for any one user, we're gonna obviously be following multiple other accounts, right? So we're gonna need another table in there
list of user IDs that I'm following, user accounts. In addition to that, we're gonna want likes. So we're gonna wanna store another, I think another foreign key to like a videos table. So I'm assuming if each account has a table of videos like we're seeing up here, we would basically have...
Sorry, I think I missed something here. We're probably gonna wanna have a video UUID, like a video ID, and this would be a UID field here so that I can key to this video ID and say that that's a list of the likes that I'm liking. And this all feeds later into the pre-cache service algorithm which I'm not gonna get into, but I think that's important to store. So basically whatever activity I have of this video.
user activity is going to hit the database, I'm going to start this up here for now. It's going to hit this database and add that to my to my to this table, right? So I'm now following this user. I'm liking this video, et cetera, so that if I ever needed to like run a get request, which sounds like the pre cash service will actually need to run some sort of request against user activity or some sort of maybe we have like an internal service that manages.
is that I'm not sure. But yeah, I have an API that would return all the users' likes and followers, essentially, as I'm getting at. And maybe that's a get request here from the user activities. But that's sort of the rough idea of what I'm thinking for that. Does that make sense from sort of a flow perspective? Yeah, that makes sense. Awesome. OK, well, yeah, I think we've got the main interactions here. We've got most of the features structurally built out.
curious as sort of a follow up here, what do you think would be sort of the bottlenecks of the system if you were to, for example, like 10x the traffic one day or something like that to really scale things up? Yeah, absolutely. So first thing I have to think about is just regions before thinking about, if we're thinking about having this multiple versions of this in regions, like regional data centers, we might I want to consider that. Just geolocating.
So my first inclination is just whatever user, we're gonna put the user behind some sort of, basically all these API endpoints are gonna wanna go behind some sort of like CDN, right? Content delivery network. So like Akamai or something like that because like the minute we grab a video, for example, let's say, in a lot of situations where we really 10x traffic, it's typically in these scenarios around like,
You know, somebody famous sends out a video, right? And we have, they have 10 million followers and everyone wants to be the video. So the idea behind the CDN is the minute the first person grabs it, the CDN caches it locally behind the, on the CDN system so that all the users who are grabbing it are just grabbing it from the CDN. And the CDN is doing like a, you know, arouting to the local, the closest know so that the internet traffic isn't always hitting my system. My blob storage, it's only hitting the CDN.
of fronts because like obviously these videos are relatively big and the scale of like in the site when we're talking about 10 million users times you know five megabytes per video that's a pretty substantial number video so putting a CDN behind that in front of that's important well I think having a load balancer in front of these API endpoints as well we'll do thing one Well, this will do a couple things. Number one.
Number one, it's going to let me commit to this highly available non-functional requirement because these API endpoints can be scalable. Then we can do things like have multiple deployments, so multiple services running. The load balancer is picking which one of these services is available at any one time and scaling them accordingly, or sorry,
So, A or B, for example. So, it's not only is it balancing between the two, but it also looks to do things like zero downtime deployment. So, if we have to update this software, the backend software that's running this, we would flip all traffic to B and only allow B to be serving traffic while A is down and getting updates, right? And A to B is a very simplistic view. view that could be hundreds of computers and such.
That's sort of the idea there. So that's kind of where I see the bottleneck. Like I said, database is always kind of a bottleneck, I think. So we'd have definitely like sort of a main right database with read-only workers that manage sort of the get requests. And these would also be in some sort of auto scaling group so that we could scale them up as needed. Same thing with the pre-cash service. I think we'd have a pretty good idea
more in detail with this, how are pre, like what we needed and what, as far as like timing and requirements around what we need for services, we have a pretty good understanding. So I don't know how auto-scaling this would have to be, it might just be able to be like set in stone or roughly equivalent to that so that we know ahead of times. Cash, similar situation, cash is a pretty scalable and things like that. The one last
thing I would think about is this right database. So if we were to 10x traffic to this, we'd want to consider doing some sort of database sharding so that we are, and we'd have some sort of database shard service here in front of this where, where we are basically, sorry, Sorry, let me just clean this up a bit.
Basically, the sharding service sits in front of all the rights. And it picks, it's like a load balancer for databases essentially. And it picks which database it's going to go to based on. There's all kinds of sharding algorithms or strategies. strategies. You can do things like the simplest version of that is like if you take
So it took maybe like a region. So all US requests go to this database, all UK requests go to this database. You can do things like that. Yeah, so that's kind of the way I would picture it 'cause that will help us to split the load between these databases. Yeah.  - Awesome. Yeah, well, I think we've got, we jumped into some details there. I think overall we've got all the pieces sort of in place
good stopping part. Do you have any sort of last things you would add to this before we sort of wrap up? - No, I think just something I might have had a little more time, I would maybe get a little bit more into the pre-cash service 'cause I think it might need its own, almost separate database structure and things like that. But I think, like I said, I don't want to get too much into the weeds with the TikTok specific algorithming kind of stuff. I think just kind of keeping it saying
somewhere and we would just use it is good enough for the purposes of this interview. So, no, I feel pretty good about it. Awesome. All right. Well, yeah, let's call it here. And, yeah, so just sort of recapping what we went over. So we talked about designing API, talked about database structure, talked about, you know, different microservices and load balancing and things like that. And I thought overall, like you did a really awesome job of really clearly communicating all these ideas and also
You know, sort of jumping in and providing extra knowledge about the specific things. Even when I asked a follow-up question, or even without asking, I feel like you really jumped in and sort of showed you had mastery over all of these topics, which was really awesome. And even though this is sort of a little bit of a condensed version of this, I feel like you could have gotten multiple layers deeper on any of these topics. So it really shows me that you know what you're talking about. But yeah, did you think of it all? Yeah, I think it's it's okay.
is interesting trying to design something that you've never used. So we're sort of, I would make a couple of assumptions on, you know, knowing, I know Facebook, I know Instagram, so I kind of understand those, but so making some assumptions on how it's used by people. Really, kind of helps. Yeah, I thought it won't work. Well, thank you so much, Adam, and good luck to everyone on your system design interview.
